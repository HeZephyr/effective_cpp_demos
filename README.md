# Effective C++ 实践示例

## 项目概述

本项目通过实际的C++示例代码实现了Scott Meyers《Effective C++》中描述的许多关键设计模式和最佳实践。每个示例都通过中文注释标注了相应的条款编号和解释，为C++开发者提供具体的代码实现参考。

## 环境要求

- C++17兼容的编译器（GCC 7+、Clang 5+或MSVC 2017+）
- 支持标准库
- Make构建系统

## 构建与运行

```bash
# 使用构建脚本构建所有示例
chmod +x build.sh
./build.sh

# 或单独构建示例
cd smart_pointers && make
cd raii_file_handler && make
# ... 依此类推
```

## Effective C++ 55个条款实现情况

### 1. 让自己习惯C++
- [x] **条款01**: 视C++ 为一个语言联邦
- [x] **条款02**: 尽量以const, enum, inline替换#define
- [x] **条款03**: 尽可能使用const
- [x] **条款04**: 确定对象被使用前已先被初始化
  - 在文件处理器、智能指针和单例模式中实现

### 2. 构造/析构/赋值运算
- [x] **条款05**: 了解C++ 默默编写并调用哪些函数
- [x] **条款06**: 若不想使用编译器自动生成的函数，就该明确拒绝
  - 在RAII文件处理器和智能指针中实现
- [x] **条款07**: 为多态基类声明virtual 析构函数
  - 在智能指针示例中实现
- [x] **条款08**: 别让异常逃离析构函数
  - 在智能指针和RAII文件处理器中实现
- [x] **条款09**: 绝不在构造和析构过程中调用virtual 函数
- [x] **条款10**: 令operator= 返回一个reference to *this
  - 在智能指针示例中实现
- [x] **条款11**: 在operator= 中处理"自我赋值"
  - 在智能指针、Pimpl和单例示例中实现
- [x] **条款12**: 复制对象时勿忘其每一个成分
  - 在Pimpl模式中实现

### 3. 资源管理
- [x] **条款13**: 以对象管理资源
  - 在RAII文件处理器和智能指针中实现
- [x] **条款14**: 在资源管理类中小心 copying 行为
  - 在智能指针和RAII文件处理器中实现
- [x] **条款15**: 在资源管理类中提供对原始资源的访问
  - 在智能指针和RAII文件处理器中实现
- [x] **条款16**: 成对使用new 和delete 时要采取相同形式
  - 在智能指针示例中实现
- [x] **条款17**: 以独立语句将newed 对象置入智能指针
  - 在智能指针和RAII文件处理器中实现

### 4. 设计和声明
- [x] **条款18**: 让接口容易被正确使用，不易被误用
- [x] **条款19**: 设计class犹如设计type
- [x] **条款20**: 宁以pass-by-reference-to-const替换pass-by-value
- [x] **条款21**: 必须返回对象时，别妄想返回其reference
- [x] **条款22**: 将成员变量声明为private
- [x] **条款23**: 宁以non-member、non-friend 替换member 函数
- [x] **条款24**: 若所有参数皆需类型转换，请为此采用non-member 函数
- [x] **条款25**: 考虑写出一个不抛异常的swap函数
  - 在Pimpl模式中实现

### 5. 实现
- [x] **条款26**: 尽可能延后变量定义式的出现时间
- [x] **条款27**: 尽量少做转型
  - 在单例模式示例中实现
- [x] **条款28**: 避免返回handles指向对象内部成分
- [x] **条款29**: 为"异常安全"努力是值得的
  - 在RAII文件处理器和单例模式中实现
- [x] **条款30**: 透彻了解inlining的里里外外
- [x] **条款31**: 将文件间的编译依存关系降至最低
  - 在Pimpl模式中实现

### 6. 继承和面向对象设计
- [x] **条款32**: 确定你的public 继承塑模出is-a关系
- [x] **条款33**: 避免遮掩继承而来的名称
- [x] **条款34**: 区分接口继承和实现继承
- [x] **条款35**: 考虑virtual函数以外的其他选择
  - 在策略模式设计示例中实现
- [x] **条款36**: 绝对不要重新定义继承而来的non-virtual函数
- [x] **条款37**: 绝对不要重新定义继承而来的缺省参数值
- [x] **条款38**: 通过复合塑模出has-a或"根据某物实现出"
  - 在策略模式设计示例中实现
- [x] **条款39**: 明智而审慎地使用private继承
- [x] **条款40**: 明智而审慎地使用多重继承

### 7. 模板与泛型编程
- [x] **条款41**: 了解隐式接口和编译期多态
  - 在策略模式设计和模板元编程示例中实现
- [x] **条款42**: 了解typename的双重意义
  - 在策略模式设计示例中实现
- [x] **条款43**: 学习处理模板化基类内的名称
  - 在策略模式设计示例中实现
- [x] **条款44**: 将与参数无关的代码抽离templates
  - 在模板元编程和表达式模板示例中实现
- [x] **条款45**: 运用成员函数模板接受所有兼容类型
- [x] **条款46**: 需要类型转换时请为模板定义非成员函数
- [x] **条款47**: 请使用traits classes表现类型信息
  - 在模板元编程示例中实现
- [x] **条款48**: 认识template元编程
  - 在模板元编程和表达式模板示例中实现

### 8. 定制new和delete
- [ ] **条款49**: 了解new-handler的行为
- [ ] **条款50**: 了解new和delete的合理替换时机
- [ ] **条款51**: 编写new和delete时需固守常规
- [ ] **条款52**: 写了placement new也要写placement delete

### 9. 杂项讨论
- [x] **条款53**: 不要轻忽编译器的警告
  - 在项目构建过程中实践
- [x] **条款54**: 让自己熟悉包括tr1在内的标准程序库
- [x] **条款55**: 让自己熟悉boost

## 每个示例中实现的条款

### 智能指针示例
条款4, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17

### RAII文件处理器
条款3, 4, 6, 7, 8, 11, 13, 14, 15, 17, 29

### Pimpl模式
条款4, 7, 11, 12, 25, 31

### 模板元编程与Traits
条款41, 42, 44, 47, 48

### 策略模式设计
条款35, 38, 41, 42, 43

### 线程安全单例模式
条款4, 6, 11, 27, 29

### 表达式模板
条款44, 48

## 参考资料

- Scott Meyers, "Effective C++: 55 Specific Ways to Improve Your Programs and Designs, 3rd Edition"
- Scott Meyers, "Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14"

## 许可证

MIT License - 详见LICENSE文件